"""
End-to-end tests for snapshot API endpoints using real restic commands.

These tests use actual restic operations and FastAPI TestClient to ensure the snapshot
management system works correctly with real API endpoints. Tests create temporary
directories and repositories to avoid affecting real data, with MC server directory structure.

IMPORTANT: These tests require restic to be installed on the system.
"""

import subprocess
import tempfile
import time
from contextlib import contextmanager
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
from fastapi.testclient import TestClient

from app.main import api_app
from app.utils.exec import exec_command


# Helper function to check if restic is available
def check_restic_available():
    """Check if restic command is available"""
    try:
        result = subprocess.run(
            ["restic", "version"], capture_output=True, text=True, timeout=5
        )
        return result.returncode == 0
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


# Skip all tests if restic is not available
pytestmark = pytest.mark.skipif(
    not check_restic_available(),
    reason="restic command not available - install restic to run these tests",
)


class MockMCInstance:
    """Mock MCInstance for testing with proper MC server structure."""

    def __init__(self, server_id: str, base_path: Path):
        self.server_id = server_id
        self.base_path = base_path
        self.project_path = base_path / server_id

    def get_project_path(self) -> Path:
        """Return the project path."""
        return self.project_path

    def get_data_path(self) -> Path:
        """Return the data path."""
        return self.project_path / "data"

    async def exists(self):
        """Return True to indicate server exists."""
        return True

    def setup_mc_server_structure(self):
        """Create realistic MC server file and directory structure."""
        # Create base directories
        self.get_data_path().mkdir(parents=True, exist_ok=True)

        # Create MC server configuration files
        (self.get_data_path() / "server.properties").write_text(
            """#Minecraft server properties
#Generated by MC Admin
server-port=25565
gamemode=survival
difficulty=normal
max-players=20
online-mode=true
level-name=world
motd=Test MC Server
allow-flight=false
spawn-protection=16
"""
        )

        (self.get_data_path() / "bukkit.yml").write_text(
            """settings:
  allow-end: true
  warn-on-overload: true
  permissions-file: permissions.yml
  update-folder: update
  plugin-profiling: false
  connection-throttle: 4000
spawn-limits:
  monsters: 70
  animals: 15
  water-animals: 5
  ambient: 15
"""
        )

        (self.get_data_path() / "paper.yml").write_text(
            """settings:
  max-joins-per-tick: 3
  track-plugin-scoreboards: false
  suggest-player-names-when-null-tab-completions: true
world-settings:
  default:
    anti-xray:
      enabled: true
      engine-mode: 1
"""
        )

        (self.get_data_path() / "ops.json").write_text("[]")
        (self.get_data_path() / "whitelist.json").write_text("[]")
        (self.get_data_path() / "banned-players.json").write_text("[]")
        (self.get_data_path() / "banned-ips.json").write_text("[]")

        # Create world directory with typical MC world structure
        world_path = self.get_data_path() / "world"
        world_path.mkdir(exist_ok=True)
        (world_path / "level.dat").write_bytes(
            b"\x1f\x8b\x08\x00\x00\x00\x00\x00"
        )  # Fake NBT data
        (world_path / "session.lock").write_bytes(b"\x00\x00\x00\x00\x00\x00\x00\x01")

        # Create region directory with fake region files
        region_path = world_path / "region"
        region_path.mkdir(exist_ok=True)
        (region_path / "r.0.0.mca").write_bytes(b"\x00" * 4096)  # Fake region file
        (region_path / "r.0.1.mca").write_bytes(b"\x00" * 8192)  # Different size

        # Create world subdirectories
        for subworld in ["DIM-1", "DIM1"]:
            subworld_path = world_path / subworld
            subworld_path.mkdir(exist_ok=True)
            (subworld_path / "region").mkdir(exist_ok=True)

        # Create plugins directory with sample plugins
        plugins_path = self.get_data_path() / "plugins"
        plugins_path.mkdir(exist_ok=True)
        (plugins_path / "EssentialsX.jar").write_bytes(
            b"\x50\x4b\x03\x04" + b"\x00" * 100
        )  # Fake JAR
        (plugins_path / "WorldEdit.jar").write_bytes(
            b"\x50\x4b\x03\x04" + b"\x00" * 150
        )  # Fake JAR

        # Plugin configs
        (plugins_path / "Essentials").mkdir(exist_ok=True)
        (plugins_path / "Essentials" / "config.yml").write_text(
            """essentials:
  command-cooldowns:
    home: 10
    tpa: 5
"""
        )

        # Create cache and temp directories
        (self.get_data_path() / "cache").mkdir(exist_ok=True)
        (self.get_data_path() / "cache" / "mojang_1.20.4.jar").write_bytes(
            b"\x00" * 1000
        )

        return self


@contextmanager
def mock_snapshot_dependencies_setup(
    instance, temp_restic_repo: Path, restic_password: str | None = "test-password"
):
    """Context manager for mocking snapshot dependencies.

    Args:
        instance: The MockMCInstance to use for testing
        temp_restic_repo: Path to temporary restic repository
        restic_password: Password for restic repository (None for no password)
    """
    # Create mock dynamic config
    mock_time_restriction = MagicMock()
    mock_time_restriction.enabled = True
    mock_time_restriction.before_seconds = 30
    mock_time_restriction.after_seconds = 60

    mock_snapshots_config = MagicMock()
    mock_snapshots_config.time_restriction = mock_time_restriction

    mock_config = MagicMock()
    mock_config.snapshots = mock_snapshots_config

    with (
        patch("app.routers.snapshots.docker_mc_manager") as mock_manager,
        patch("app.routers.snapshots.settings") as mock_settings,
        patch("app.routers.servers.files.docker_mc_manager") as mock_file_manager,
        patch("app.dependencies.settings") as mock_dep_settings,
        patch("app.routers.snapshots.config", mock_config),
        patch(
            "app.routers.snapshots.restart_scheduler.get_backup_minutes",
            return_value=set(),
        ),  # No backup jobs by default
    ):
        # Mock settings for snapshots
        mock_settings.server_path = instance.base_path
        mock_settings.restic.repository_path = str(temp_restic_repo)
        mock_settings.restic.password = restic_password

        # Mock settings for dependencies (master token)
        mock_dep_settings.master_token = "test_master_token"

        # Mock MC managers
        mock_manager.get_instance.return_value = instance
        mock_file_manager.get_instance.return_value = instance

        yield


class TestSnapshotEndpoints:
    """End-to-end tests for snapshot API endpoints using real restic operations."""

    @pytest.fixture
    def client(self):
        """Create test client."""
        return TestClient(api_app)

    @pytest.fixture
    def temp_server_dir(self):
        """Create temporary directory for MC server."""
        with tempfile.TemporaryDirectory(prefix="mc_snapshot_test_") as temp_dir:
            yield Path(temp_dir)

    @pytest.fixture
    def temp_restic_repo(self):
        """Create temporary directory for restic repository."""
        with tempfile.TemporaryDirectory(prefix="restic_repo_test_") as temp_dir:
            yield Path(temp_dir)

    @pytest.fixture
    def mock_instance(self, temp_server_dir):
        """Create mock instance with realistic MC server structure."""
        server_id = "test_server"
        instance = MockMCInstance(server_id, temp_server_dir)
        instance.setup_mc_server_structure()
        return server_id, instance

    @pytest.fixture
    async def initialized_restic_repo(self, temp_restic_repo):
        """Initialize restic repository."""

        env = {
            "RESTIC_REPOSITORY": str(temp_restic_repo),
            "RESTIC_PASSWORD": "test-password",
        }

        try:
            await exec_command("restic", "init", env=env)
        except Exception as e:
            pytest.fail(f"Failed to initialize restic repository: {e}")

        return temp_restic_repo

    @pytest.fixture
    async def initialized_restic_repo_no_password(self, temp_restic_repo):
        """Initialize restic repository without password."""

        env = {
            "RESTIC_REPOSITORY": str(temp_restic_repo),
        }

        try:
            await exec_command("restic", "init", "--insecure-no-password", env=env)
        except Exception as e:
            pytest.fail(f"Failed to initialize restic repository without password: {e}")

        return temp_restic_repo

    @pytest.mark.asyncio
    async def test_create_server_snapshot_endpoint(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test creating a server snapshot via API endpoint."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )

            assert response.status_code == 200
            data = response.json()

            # Verify response structure
            assert "message" in data
            assert "snapshot" in data
            assert "Snapshot created successfully" in data["message"]

            # Verify snapshot details
            snapshot = data["snapshot"]
            assert snapshot["id"] is not None
            assert len(snapshot["id"]) == 64  # SHA256 hash
            assert snapshot["short_id"] is not None
            assert len(snapshot["short_id"]) == 8
            assert len(snapshot["paths"]) > 0
            assert str(instance.project_path) in snapshot["paths"]

            # Verify summary information
            if "summary" in snapshot and snapshot["summary"]:
                summary = snapshot["summary"]
                assert "total_files_processed" in summary
                assert summary["total_files_processed"] > 0
                assert "total_bytes_processed" in summary
                assert summary["total_bytes_processed"] > 0

    @pytest.mark.asyncio
    async def test_list_server_snapshots_endpoint(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test listing server snapshots via API endpoint."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Create a snapshot first
            create_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert create_response.status_code == 200
            created_snapshot_id = create_response.json()["snapshot"]["id"]

            # List snapshots
            list_response = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )

            assert list_response.status_code == 200
            data = list_response.json()

            # Verify response structure
            assert "snapshots" in data
            assert len(data["snapshots"]) == 1

            # Verify snapshot details
            snapshot = data["snapshots"][0]
            assert snapshot["id"] == created_snapshot_id
            assert str(instance.project_path) in snapshot["paths"]

    @pytest.mark.asyncio
    async def test_snapshot_restore_preview_endpoint(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test snapshot restore preview via API endpoint."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Create a snapshot
            create_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert create_response.status_code == 200
            snapshot_id = create_response.json()["snapshot"]["id"]

            # Modify some files to create changes
            (instance.get_data_path() / "server.properties").write_text(
                "server-port=25566\nmodified=true"
            )
            (instance.get_data_path() / "new_file.txt").write_text("This is a new file")

            # Preview restore
            preview_response = client.post(
                "/snapshots/restore/preview",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": snapshot_id, "server_id": server_id},
            )

            assert preview_response.status_code == 200
            data = preview_response.json()

            # Verify response structure
            assert "actions" in data
            assert "preview_summary" in data
            assert len(data["actions"]) > 0

            # Verify preview summary format - check for Chinese or English text patterns
            summary = data["preview_summary"]
            # Check if it contains either Chinese or English patterns for file operations
            has_file_operations = (
                "updated" in summary
                or "deleted" in summary
                or "restored" in summary
                or "更新" in summary
                or "删除" in summary
                or "恢复" in summary
            )
            assert has_file_operations, (
                f"Preview summary should contain file operation indicators: {summary}"
            )

            # Verify actions contain required fields
            for action in data["actions"]:
                assert "message_type" in action
                assert action["message_type"] == "verbose_status"
                assert "action" in action
                assert action["action"] in ["updated", "deleted", "restored"]
                assert "item" in action
                assert "size" in action

    @pytest.mark.asyncio
    async def test_snapshot_restore_with_files_api_verification(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test actual snapshot restore and verify using files API endpoints."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Record original file contents using files API
            original_props_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert original_props_response.status_code == 200
            original_props_content = original_props_response.json()["content"]

            # List original files using files API (verify structure exists)
            original_files_response = client.get(
                f"/servers/{server_id}/files",
                headers={"Authorization": "Bearer test_master_token"},
            )
            assert original_files_response.status_code == 200
            assert len(original_files_response.json()["items"]) > 0

            # Create initial snapshot
            snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot_response.status_code == 200
            snapshot_id = snapshot_response.json()["snapshot"]["id"]

            # Modify files using files API
            modified_content = "# MODIFIED CONFIG\nserver-port=25566\nmax-players=10"
            modify_response = client.post(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
                json={"content": modified_content},
            )
            assert modify_response.status_code == 200

            # Create new file using files API
            create_response = client.post(
                f"/servers/{server_id}/files/create",
                headers={"Authorization": "Bearer test_master_token"},
                json={"name": "new_config.yml", "type": "file", "path": "/"},
            )
            assert create_response.status_code == 200

            # Upload file using files API
            upload_response = client.post(
                f"/servers/{server_id}/files/upload",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/"},
                files={"file": ("uploaded.txt", b"uploaded content", "text/plain")},
            )
            assert upload_response.status_code == 200

            # Verify modifications
            modified_props_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert modified_props_response.status_code == 200
            assert modified_props_response.json()["content"] != original_props_content

            # Get snapshot count before restore
            snapshots_before_restore = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )
            snapshot_count_before = len(snapshots_before_restore.json()["snapshots"])

            # Restore original snapshot (should automatically create a safety snapshot)
            restore_response = client.post(
                "/snapshots/restore",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": snapshot_id, "server_id": server_id},
            )
            assert restore_response.status_code == 200
            assert "safety_snapshot_id" in restore_response.json()
            assert restore_response.json()["safety_snapshot_id"] is not None

            # Verify a new safety snapshot was created
            snapshots_after_restore = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )
            snapshot_count_after = len(snapshots_after_restore.json()["snapshots"])
            assert snapshot_count_after == snapshot_count_before + 1

            # Verify restoration using files API
            restored_props_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert restored_props_response.status_code == 200
            restored_content = restored_props_response.json()["content"]
            assert restored_content == original_props_content

            # Verify uploaded file was deleted (restore with --delete)
            uploaded_file_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/uploaded.txt"},
            )
            assert uploaded_file_response.status_code == 404

            # Verify created file was deleted
            created_file_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/new_config.yml"},
            )
            assert created_file_response.status_code == 404

    @pytest.mark.asyncio
    async def test_snapshot_path_filtering_endpoint(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test snapshot creation and listing with path filtering."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Create snapshot of entire server
            full_snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert full_snapshot_response.status_code == 200
            full_snapshot_id = full_snapshot_response.json()["snapshot"]["id"]

            # Modify a file to ensure the next snapshot will be different
            time.sleep(0.2)
            (instance.get_data_path() / "server.properties").write_text(
                "# Modified config\nserver-port=25566"
            )

            # Create second snapshot of entire server (with changes)
            modified_snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert modified_snapshot_response.status_code == 200
            modified_snapshot_id = modified_snapshot_response.json()["snapshot"]["id"]

            # Verify snapshots have different IDs
            assert full_snapshot_id != modified_snapshot_id

            # List all snapshots for this server
            all_snapshots_response = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )
            assert all_snapshots_response.status_code == 200
            all_snapshots = all_snapshots_response.json()["snapshots"]
            all_snapshot_ids = {s["id"] for s in all_snapshots}

            # Should have exactly 2 snapshots
            assert len(all_snapshots) == 2
            assert full_snapshot_id in all_snapshot_ids
            assert modified_snapshot_id in all_snapshot_ids

            # Verify both snapshots have the same server path but different times
            for snapshot in all_snapshots:
                assert str(instance.project_path) in snapshot["paths"]

            # Test creating and listing a plugins-only snapshot separately
            time.sleep(0.2)
            (instance.get_data_path() / "plugins" / "test-plugin.jar").write_bytes(
                b"fake jar content"
            )

            plugins_snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id, "path": "/plugins"},
            )
            assert plugins_snapshot_response.status_code == 200
            plugins_snapshot_id = plugins_snapshot_response.json()["snapshot"]["id"]

            # List snapshots by plugins path - should only return snapshots containing plugins
            plugins_snapshots_response = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id, "path": "/plugins"},
            )
            assert plugins_snapshots_response.status_code == 200
            plugins_snapshots = plugins_snapshots_response.json()["snapshots"]

            # Should include the full server snapshots (because they contain plugins)
            # Note: plugins-specific snapshot (plugins_snapshot_id) may or may not appear
            # based on the path filtering implementation logic
            plugins_snapshot_ids = {s["id"] for s in plugins_snapshots}
            assert full_snapshot_id in plugins_snapshot_ids, (
                "Full snapshot should be included (contains plugins)"
            )
            assert modified_snapshot_id in plugins_snapshot_ids, (
                "Modified snapshot should be included (contains plugins)"
            )

            # Verify plugins snapshot was created (even if not in filtered list)
            assert plugins_snapshot_id != full_snapshot_id
            assert plugins_snapshot_id != modified_snapshot_id

    @pytest.mark.asyncio
    async def test_snapshot_error_handling(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test error handling in snapshot endpoints."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Test restore with invalid snapshot ID
            invalid_restore_response = client.post(
                "/snapshots/restore",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": "invalid-snapshot-id", "server_id": server_id},
            )
            assert invalid_restore_response.status_code == 500
            response_detail = invalid_restore_response.json()["detail"]
            assert (
                "Failed to restore" in response_detail or "invalid" in response_detail
            )

            # Test preview with invalid snapshot ID
            invalid_preview_response = client.post(
                "/snapshots/restore/preview",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": "invalid-snapshot-id", "server_id": server_id},
            )
            assert invalid_preview_response.status_code == 500
            assert (
                "Failed to preview restore" in invalid_preview_response.json()["detail"]
            )

    @pytest.mark.asyncio
    async def test_unauthorized_access(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test unauthorized access to snapshot endpoints."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Test without authorization header
            response = client.post("/snapshots", json={"server_id": server_id})
            assert response.status_code in [401, 422]

            # Test with invalid token
            response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer invalid_token"},
                json={"server_id": server_id},
            )
            assert response.status_code in [401, 422]

    @pytest.mark.asyncio
    async def test_comprehensive_mc_server_restore_integrity(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test comprehensive MC server file integrity after restore."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Capture original MC server structure using files API
            original_structure = {}

            # Get root directory listing
            root_response = client.get(
                f"/servers/{server_id}/files",
                headers={"Authorization": "Bearer test_master_token"},
            )
            assert root_response.status_code == 200

            # Recursively capture file contents for key MC files
            key_files = [
                "/server.properties",
                "/bukkit.yml",
                "/paper.yml",
                "/plugins/Essentials/config.yml",
            ]

            for file_path in key_files:
                file_response = client.get(
                    f"/servers/{server_id}/files/content",
                    headers={"Authorization": "Bearer test_master_token"},
                    params={"path": file_path},
                )
                if file_response.status_code == 200:
                    original_structure[file_path] = file_response.json()["content"]

            # Create snapshot of entire server
            snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot_response.status_code == 200
            snapshot_id = snapshot_response.json()["snapshot"]["id"]

            # Simulate server modifications (corrupt configs, add unwanted files)
            corrupted_props = "# CORRUPTED\nserver-port=invalid\nmax-players=999999"
            client.post(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
                json={"content": corrupted_props},
            )

            # Add unwanted files
            client.post(
                f"/servers/{server_id}/files/create",
                headers={"Authorization": "Bearer test_master_token"},
                json={"name": "malware.exe", "type": "file", "path": "/"},
            )

            # Delete important files
            client.delete(
                f"/servers/{server_id}/files",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/bukkit.yml"},
            )

            # Restore (will automatically create safety snapshot)
            restore_response = client.post(
                "/snapshots/restore",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": snapshot_id, "server_id": server_id},
            )
            assert restore_response.status_code == 200
            assert "safety_snapshot_id" in restore_response.json()

            # Verify complete restoration using files API
            for file_path, expected_content in original_structure.items():
                restored_response = client.get(
                    f"/servers/{server_id}/files/content",
                    headers={"Authorization": "Bearer test_master_token"},
                    params={"path": file_path},
                )
                assert restored_response.status_code == 200
                restored_content = restored_response.json()["content"]
                assert restored_content == expected_content

            # Verify unwanted files were removed
            malware_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/malware.exe"},
            )
            assert malware_response.status_code == 404

    @pytest.mark.asyncio
    async def test_partial_restore_scope_verification(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test that partial restore only affects specified subdirectory, not other areas."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Record original content from both subdirectory and root directory
            plugins_config_original = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/plugins/Essentials/config.yml"},
            )
            assert plugins_config_original.status_code == 200
            plugins_original_content = plugins_config_original.json()["content"]

            # Verify server.properties exists (we'll verify it remains modified later)
            server_props_original = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert server_props_original.status_code == 200

            # Create initial snapshot
            snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot_response.status_code == 200
            snapshot_id = snapshot_response.json()["snapshot"]["id"]

            # Modify files in both subdirectory (plugins) and root directory (data)
            # 1. Modify file in plugins subdirectory
            plugins_modified_content = """# MODIFIED PLUGINS CONFIG
essentials:
  command-cooldowns:
    home: 30
    tpa: 15
  modified: true
"""
            plugins_modify_response = client.post(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/plugins/Essentials/config.yml"},
                json={"content": plugins_modified_content},
            )
            assert plugins_modify_response.status_code == 200

            # 2. Modify file in root data directory
            server_props_modified_content = """# MODIFIED SERVER CONFIG
server-port=25567
gamemode=creative
difficulty=hard
max-players=50
modified=true
"""
            server_props_modify_response = client.post(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
                json={"content": server_props_modified_content},
            )
            assert server_props_modify_response.status_code == 200

            # Verify both files are modified
            plugins_check = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/plugins/Essentials/config.yml"},
            )
            assert plugins_check.status_code == 200
            assert plugins_check.json()["content"] == plugins_modified_content

            server_props_check = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert server_props_check.status_code == 200
            assert server_props_check.json()["content"] == server_props_modified_content

            # Restore ONLY the plugins subdirectory to the original snapshot
            # (will automatically create safety snapshot)
            restore_response = client.post(
                "/snapshots/restore",
                headers={"Authorization": "Bearer test_master_token"},
                json={
                    "snapshot_id": snapshot_id,
                    "server_id": server_id,
                    "path": "/plugins",
                },
            )
            assert restore_response.status_code == 200
            assert "safety_snapshot_id" in restore_response.json()

            # Verify plugins subdirectory was restored to original state
            plugins_restored_check = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/plugins/Essentials/config.yml"},
            )
            assert plugins_restored_check.status_code == 200
            assert (
                plugins_restored_check.json()["content"] == plugins_original_content
            ), "Plugins config should be restored to original state"

            # Verify root directory file was NOT affected by partial restore
            server_props_final_check = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert server_props_final_check.status_code == 200
            assert (
                server_props_final_check.json()["content"]
                == server_props_modified_content
            ), (
                "Server properties should remain modified (not affected by plugins-only restore)"
            )

            # Additional verification: Check that other subdirectories weren't affected
            # Create a test file in world directory before restore and verify it persists
            world_test_content = "This file should not be affected by plugins restore"
            world_test_response = client.post(
                f"/servers/{server_id}/files/create",
                headers={"Authorization": "Bearer test_master_token"},
                json={
                    "name": "test_after_snapshot.txt",
                    "type": "file",
                    "path": "/world",
                },
            )
            if world_test_response.status_code == 200:
                # Set content for the test file
                client.post(
                    f"/servers/{server_id}/files/content",
                    headers={"Authorization": "Bearer test_master_token"},
                    params={"path": "/world/test_after_snapshot.txt"},
                    json={"content": world_test_content},
                )

                # Verify the world directory file persists after plugins restore
                world_final_check = client.get(
                    f"/servers/{server_id}/files/content",
                    headers={"Authorization": "Bearer test_master_token"},
                    params={"path": "/world/test_after_snapshot.txt"},
                )
                assert world_final_check.status_code == 200, (
                    "Files in other subdirectories should not be affected by plugins-only restore"
                )
                assert world_final_check.json()["content"] == world_test_content

    @pytest.mark.asyncio
    async def test_create_snapshot_no_password(
        self, client, mock_instance, initialized_restic_repo_no_password
    ):
        """Test creating a snapshot with no password repository."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(
            instance, initialized_restic_repo_no_password, restic_password=None
        ):
            response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )

            assert response.status_code == 200
            data = response.json()

            # Verify response structure
            assert "message" in data
            assert "snapshot" in data
            assert "Snapshot created successfully" in data["message"]

            # Verify snapshot details
            snapshot = data["snapshot"]
            assert snapshot["id"] is not None
            assert len(snapshot["id"]) == 64  # SHA256 hash
            assert snapshot["short_id"] is not None
            assert len(snapshot["short_id"]) == 8
            assert len(snapshot["paths"]) > 0
            assert str(instance.project_path) in snapshot["paths"]

    @pytest.mark.asyncio
    async def test_list_snapshots_no_password(
        self, client, mock_instance, initialized_restic_repo_no_password
    ):
        """Test listing snapshots with no password repository."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(
            instance, initialized_restic_repo_no_password, restic_password=None
        ):
            # Create a snapshot first
            create_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert create_response.status_code == 200
            created_snapshot_id = create_response.json()["snapshot"]["id"]

            # List snapshots
            list_response = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )

            assert list_response.status_code == 200
            data = list_response.json()

            # Verify response structure
            assert "snapshots" in data
            assert len(data["snapshots"]) == 1

            # Verify snapshot details
            snapshot = data["snapshots"][0]
            assert snapshot["id"] == created_snapshot_id
            assert str(instance.project_path) in snapshot["paths"]

    @pytest.mark.asyncio
    async def test_restore_preview_no_password(
        self, client, mock_instance, initialized_restic_repo_no_password
    ):
        """Test restore preview with no password repository."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(
            instance, initialized_restic_repo_no_password, restic_password=None
        ):
            # Create a snapshot
            create_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert create_response.status_code == 200
            snapshot_id = create_response.json()["snapshot"]["id"]

            # Modify some files to create changes
            (instance.get_data_path() / "server.properties").write_text(
                "server-port=25566\nmodified=true"
            )
            (instance.get_data_path() / "new_file.txt").write_text("This is a new file")

            # Preview restore
            preview_response = client.post(
                "/snapshots/restore/preview",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": snapshot_id, "server_id": server_id},
            )

            assert preview_response.status_code == 200
            data = preview_response.json()

            # Verify response structure
            assert "actions" in data
            assert "preview_summary" in data
            assert len(data["actions"]) > 0

    @pytest.mark.asyncio
    async def test_restore_no_password(
        self, client, mock_instance, initialized_restic_repo_no_password
    ):
        """Test actual restore with no password repository."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(
            instance, initialized_restic_repo_no_password, restic_password=None
        ):
            # Record original file content
            original_props_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert original_props_response.status_code == 200
            original_props_content = original_props_response.json()["content"]

            # Create initial snapshot
            snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot_response.status_code == 200
            snapshot_id = snapshot_response.json()["snapshot"]["id"]

            # Modify file
            modified_content = "# MODIFIED CONFIG\nserver-port=25566\nmax-players=10"
            modify_response = client.post(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
                json={"content": modified_content},
            )
            assert modify_response.status_code == 200

            # Restore (will automatically create safety snapshot)
            restore_response = client.post(
                "/snapshots/restore",
                headers={"Authorization": "Bearer test_master_token"},
                json={"snapshot_id": snapshot_id, "server_id": server_id},
            )
            assert restore_response.status_code == 200
            assert "safety_snapshot_id" in restore_response.json()

            # Verify restoration
            restored_props_response = client.get(
                f"/servers/{server_id}/files/content",
                headers={"Authorization": "Bearer test_master_token"},
                params={"path": "/server.properties"},
            )
            assert restored_props_response.status_code == 200
            restored_content = restored_props_response.json()["content"]
            assert restored_content == original_props_content

    @pytest.mark.asyncio
    async def test_no_password_empty_string(
        self, client, mock_instance, initialized_restic_repo_no_password
    ):
        """Test that empty string password is treated as no password."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(
            instance, initialized_restic_repo_no_password, restic_password=""
        ):
            response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )

            assert response.status_code == 200
            data = response.json()
            assert "Snapshot created successfully" in data["message"]

    @pytest.mark.asyncio
    async def test_delete_snapshot(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test deleting a specific snapshot by ID."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Create first snapshot
            snapshot1_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot1_response.status_code == 200
            snapshot1_id = snapshot1_response.json()["snapshot"]["id"]

            # Modify a file to ensure the next snapshot will be different
            time.sleep(0.2)
            (instance.get_data_path() / "server.properties").write_text(
                "# Modified config\nserver-port=25566"
            )

            # Create second snapshot
            snapshot2_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot2_response.status_code == 200
            snapshot2_id = snapshot2_response.json()["snapshot"]["id"]

            # Verify both snapshots exist
            list_response = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )
            assert list_response.status_code == 200
            snapshots = list_response.json()["snapshots"]
            assert len(snapshots) == 2
            snapshot_ids = {s["id"] for s in snapshots}
            assert snapshot1_id in snapshot_ids
            assert snapshot2_id in snapshot_ids

            # Delete first snapshot
            delete_response = client.delete(
                f"/snapshots/{snapshot1_id}",
                headers={"Authorization": "Bearer test_master_token"},
            )
            assert delete_response.status_code == 200
            assert "deleted successfully" in delete_response.json()["message"]

            # Verify only second snapshot remains
            list_after_delete = client.get(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                params={"server_id": server_id},
            )
            assert list_after_delete.status_code == 200
            remaining_snapshots = list_after_delete.json()["snapshots"]
            assert len(remaining_snapshots) == 1
            assert remaining_snapshots[0]["id"] == snapshot2_id

    @pytest.mark.asyncio
    async def test_delete_snapshot_unauthorized(
        self, client, mock_instance, initialized_restic_repo
    ):
        """Test deleting a snapshot without authorization."""
        server_id, instance = mock_instance

        with mock_snapshot_dependencies_setup(instance, initialized_restic_repo):
            # Create a snapshot first
            snapshot_response = client.post(
                "/snapshots",
                headers={"Authorization": "Bearer test_master_token"},
                json={"server_id": server_id},
            )
            assert snapshot_response.status_code == 200
            snapshot_id = snapshot_response.json()["snapshot"]["id"]

            # Try to delete without authorization
            delete_response = client.delete(f"/snapshots/{snapshot_id}")
            assert delete_response.status_code in [401, 422]


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
